# 블록체인은 어떻게 구현되어 있는가?
먼저 블록체인과 관련된 개념들부터 알아보자.  
1. 블록 (Block) - 블록체인을 구성하는 데이터의 하나의 단위라고 할 수 있다. 기본적으로 이전 블록의 참조 값, 그리고 거래 내역 정보를 담고있다.
2. 최초 블록 (Genesis Block) - 블록체인은 처음 생성된 블록에서 한 방향으로만 확장되는데, 블록체인 상에서 가장 처음 생성된 블록을 최초 블록이라 한다.
3. 채굴 (Mining) - 새로운 블록을 생성하는 작업인데, 보통 대부분의 가상화폐는 발행을 위해 많은 컴퓨팅 자원을 이용해 문제를 풀어야만 새로운 블록을 생성 할 수 있고, 이 작업은 네트워크 상에서 가상화폐가 무작정 발행되는 것을 막기 위한 것이라고 볼 수 있다.
4. 작업 증명 (Proof-Of-Work) - 채굴 과정에서 새로운 블록을 찾아내기 위해 쓰이는 알고리즘 데이터로, `nonce` 라고 불리는 값을 알아내는 작업이라고도 할 수 있다. 각 블록에서 이 값을 구하는 난이도를 조절, 블록의 채굴 속도를 조절할 수 있다.
5. 머클 트리 (Merkle Tree) - 일종의 이진 트리로, 거래 내역에 대한 요약 정보를 해쉬값으로 갖고있다. 거래 데이터가 많아서 데이터들을 보다 효율적으로 검증하기 위해 사용되는 데이터 구조라 할 수 있다.

## 블록의 구성
블록은 위에서도 말했듯이 블록체인을 구성하는 하나의 단위이고, 이 블록들이 서로 연결되어 블록체인을 구성한다. 여기서 가장 중요한건 각각의 블록들을 연결하기 위한 이전 블록의 해쉬값을 갖고 있는 것과 거래내역을 가지고 있어야 한다. 각 블록은 `블록 크기`, `블록 헤더`, `거래 카운트`, `거래` 총 네가지의 구성 요소로 볼 수 있다. 블록 헤더는 하나의 구조체 혹은 클래스로 관리, 더 많은 내용이 있을 예정이라서 뒤에서 다루겠다. 이를 하나의 클래스로 구현해보자.
```cs
public class Block
{
    private int blockSize;
    private BlockHeader blockHeader;
    private int transanctionCount;
    private List<Object> transanctionList;
}
```
위에서 말한 구성 요소는 다 넣었다. 이제 각각 어떻게 이용하는지 알아보자.  
* 블록 크기 `(int blockSize)` - 해당 변수를 제외한 나머지 데이터들의 크기를 바이트 단위로 표현한 것.
* 블록 헤더 `(BlockHeader blockHeader)` - 해당 블록의 메타 데이터를 담는 객체.
* 거래 카운트 `(int transanctionCount)` - 거래의 수를 저장하는 변수.
* 거래 `(List<Object> transanctionList)` - 각각의 거래 정보를 담은 리스트.

여기서 블록 헤더랑 거래가 조금 불분명하게 설명되어 있다. 조금 더 자세하게 알아보자.

## 블록 헤더
위에서 설명했듯이 블록의 메타 데이터를 담고 있다. 순서대로 `버전`, `이전 블록의 해시`, `머클 루트의 해시`, `타임스탬프`, `난이도 목표`, `난스` 총 6개의 구성 요소로 이루어져있다. 이를 하나의 클래스로 구현해보자.
```cs
public class BlockHeader
{
    private int merkleRootHash;
    private int version;
    private byte[] prevBlockHash;
    private int timeStamp;
    private int bits;
    private int nonce;
}
```
버전은 그냥 소프트웨어나 프로토콜의 버전 정보를 뜻한다.  
여기서 헷갈리면 안된다! 이전 블록의 해시는 블록 '전체' 의 해시가 아닌, 이전 블록 '헤더' 의 해시값이다.  
우리가 중요하게 봐야할 것은 이전 블록의 해시, 난이도(bits), 그리고 난스이다. 이 세가지가 가장 중요하다.  
우리는 `이전 블록의 해시값` 을 가지고 각 블록들을 연결할 것이고, 이 블록을 `채굴` 하기 위해서는 `nonce` 의 값을 구해야한다. 이는 블록체인의 보안을 유지하기 위함으로, 대강 방정식 푸는거라고 생각해도 될 것 같다. 바로 이 작업이 `작업 증명, (Proof Of Work)` 이다.  

## 작업 증명 (Proof Of Work)
블록체인의 모든 블록은 상기한 데이터들, 그리고 헤더와 거래 목록으로 이루어져있다. 그리고 헤더는 바로 위에 어떤 데이터들이 있는지 적어두었다.  

새로운 블록의 nonce값을 구할 때는 이렇게 한다. 블록 헤더에 있는 데이터를 전부 SHA-256 함수에 때려넣고 반환된 32바이트의 값을 구한다. 그리고 이 값을 다시 SHA-256에 때려넣어서 나온 해시값이 난이도 목표보다 작은지 비교하는 것이다. 이 때, nonce를 제외한 값은 모두 정해져있기 때문에 nonce는 0부터 쭉~ 1씩 더하며 반복 노가다를 돌리는 것이다. 바로 이 작업이 '작업 증명' 이자, 우리가 귀에 피나도록 들은 '채굴' 이라고 할 수 있다. 물론 채굴은 작업 증명에 거래 수수료를 받는 추가적인 작업이지만, 여기서는 채굴은 기본적으로 이 작업이 동반된다고 이해하면 될 것 같다.  

다음과 같은 차례로 이루어진다고 나는 이해했다.  
1. 블록이 생성된다. 이전 블록만 하나라도 있으면 nonce값 빼고 모든걸 다 생성하는 사람 시점에서 결정되기 때문에, 누군가 생성을 할 것이다.
2. 마이너(Miner)는 이제 이 블록을 찾아낸다. 예를 들어 초기 nonce 값을 -1로 설정해둔다면, nonce가 -1인 블록은 아직 누군가의 소유가 되지 않은 블록이겠지.
3. 그럼 마이너는 이 블록의 nonce 값을 구하기 위한 연산을 시작, nonce 값을 구했다면 거래를 통해 자신의 소유로 만들며- 해당 결과를 블록체인에 뿌린다. 동시에 블록이 블록체인에 연결되어 다른 블록을 만들 수 있는, 즉 생성된 블록은 다른 블록의 '이전 블록의 해시' 가 될 수 있는 상태가 된다. 

다른 블록을 생성하고 싶을 때는 이 블록을 double SHA-256을 돌려 이전 블록의 해시로 등록해서 블록을 생성, 다시 nonce값을 찾는 채굴 노예의 여정이 시작된다.

